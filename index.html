<!doctype html> 
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Antenna Polar Plot</title>

  <!-- Plotly CDN -->
  <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>

  <style>
    :root {
      --bg: #2b2b2b;
      --elements: #454545;
      --accent: #ffffff;
      --muted: #c7c7c7;
      --card: #0b1220;
      --danger: #ff6b6b;
      --gap: 8px;
    }

    html, body {
      height: 100%;
      margin: 0;
      font-family: Inter, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--bg);
      color: #e6eef5;
    }

    .app {
      display: grid;
      grid-template-columns: 1fr 350px;
      gap: 18px;
      padding: 18px;
      height: 100vh;
      box-sizing: border-box;
    }

    /* LEFT - plot */
    .left {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .toolbar {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .btn {
      background: var(--elements);
      border: 1px solid rgba(255, 255, 255, 0.19);
      color: var(--accent);
      padding: 6px 10px;
      border-radius: 6px;
      cursor: pointer;
      white-space: nowrap;
    }

    .btn:active {
      transform: translateY(1px);
    }

    .small {
      padding: 6px 8px;
    }

    #error {
      min-height: 40px;
      color: var(--danger);
      font-size: 0.95rem;
    }

    /* Plot area */
    #plot {
      flex: 1 1 auto;
      border-radius: 12px;
      overflow: hidden;
      background: linear-gradient(180deg, rgba(0,0,0,0.15), rgba(0,0,0,0.05));
      box-shadow: 0 6px 18px rgba(4, 6, 10, 0.6);
    }

    /* RIGHT - controls */
    .right {
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: stretch;
    }

    .row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    label {
      color: var(--muted);
      font-size: 0.95rem;
      white-space: nowrap;
    }

    input[type="text"],
    input[type="number"] {
      background: #393939;
      border: 1px solid rgba(255, 255, 255, 0.06);
      color: inherit;
      font-family: Inter, Segoe UI, Roboto, Arial, sans-serif;
      font-size: 1em;
      padding: 2px 8px;
      border-radius: 6px;
      outline: none;
    }

    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    /* Field container */
    .fields {
      display: grid;
      grid-template-columns: 1fr;
      gap: 6px;
      max-height: 88vh;
      overflow: auto;
      margin-top: 8px;
      padding-right: 6px;
    }

    /* Each field row */
    .field-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
    }

    #db_range {
      flex: 1;
      display: flex;
      justify-content: flex-end;
    }

    /* Responsive for small screens */
    @media (max-width: 1040px) {
      .fields {
        grid-template-columns: repeat(4, 1fr);
      }

      .field-row {
        margin-bottom: 4px;
      }
    }

    .deg {
      width: 56px;
      text-align: right;
      color: var(--muted);
      font-variant-numeric: tabular-nums;
      flex-shrink: 0;
    }

    .db-input {
      width: 80px;
    }

    .hint {
      color: var(--muted);
      font-size: 0.9rem;
      margin-top: 6px;
    }

    /* Responsive */
    @media (max-width: 1040px) {
      .app {
        grid-template-columns: 1fr;
        grid-auto-rows: auto 1fr;
      }

      .right {
        order: 2;
      }

      .left {
        order: 1;
      }

      #plot {
        height: 60vh;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="left">
      <div class="toolbar">
        <button id="saveBtn" class="btn small">Save</button>
        <button id="drawBtn" class="btn small">Draw</button>
        <button id="mirrorBtn" class="btn small">Mirror L to R</button>
        <div id="db_range">
          <!-- Range controls -->
          <div class="row" style="align-items:center;">
            <label style="margin-right:6px">Min dB:</label>
            <input id="minDbInput" type="number" step="1" value="-100" style="width:80px" />
            <label style="margin-left:6px">Max dB:</label>
            <input id="maxDbInput" type="number" step="1" value="0" style="width:80px" />
            <button id="setRangeBtn" class="btn small" style="margin-left:8px">Set range</button>
            <button id="toggleModeBtn" class="btn small" style="margin-left:8px">Non-linear</button>
          </div>

        </div>
      </div>

      <div id="plot" class="elements" aria-label="Polar plot container"></div>
      <div id="error" aria-live="polite"></div>
    </div>

    <div class="right">
      <div class="row">
        <label style="margin-right:6px">Step:</label>
        <input id="stepInput" type="number" min="1" max="180" value="30" style="width:80px" />
        <label>° (deg)</label>
        <button id="setStepBtn" class="btn small" style="margin-left:8px">Set</button>
        <button id="clearFieldsBtn" class="btn small" style="margin-left:8px">Clear fields</button>
      </div>

      <div class="elements">
        <div class="row" style="justify-content:space-between">
          <span>dB values (angles)</span>
        </div>
        <div id="fields" class="fields" aria-label="dB fields"></div>
      </div>
    </div>
  </div>

  <script>
    /*
     * Antenna Polar Plot - Web Version (updated)
     * - Added Min/Max dB inputs and Set range button
     * - Circular line count is always 10; step = (max-min)/10
     * - Only first 4 (closest to max) values are labeled; other concentric circles are unlabeled
     * - User-entered Min/Max and field values are stored in localStorage
     */

    (function() {
      // ========== Configuration ==========
      const SMOOTH_POINTS = 360;           // resolution for circles/smooth trace
      const THETA_OFFSET = Math.PI / 2;
      const DB_REGEX = /-?\d+(?:[.,]\d+)?/;
      const NUM_CIRCLES = 10; // <-- change this to whatever you want

      // ========== DOM Elements ==========
      const stepInput = document.getElementById('stepInput');
      const setStepBtn = document.getElementById('setStepBtn');
      const drawBtn = document.getElementById('drawBtn');
      const saveBtn = document.getElementById('saveBtn');
      const mirrorBtn = document.getElementById('mirrorBtn');
      const clearFieldsBtn = document.getElementById('clearFieldsBtn');
      const fieldsContainer = document.getElementById('fields');
      const errorEl = document.getElementById('error');
      const plotDiv = document.getElementById('plot');

      // Range elements
      const minDbInput = document.getElementById('minDbInput');
      const maxDbInput = document.getElementById('maxDbInput');
      const setRangeBtn = document.getElementById('setRangeBtn');

      // ========== State ==========
      let currentStep = parseInt(stepInput.value) || 30;
      let dbInputs = [];
      let prevTexts = [];
      let hasDataPlotted = false; // tracks if user line has been drawn
      let isNonLinearMode = true; // default db division mode


      // Default range
      let minDb = -100;
      let maxDb = 0;

      // ========== Math / Mapping Functions ==========

      /**
       * Format db nicely (trim trailing zeros)
       */
      function formatDb(v) {
        if (Math.abs(Math.round(v) - v) < 1e-9) return String(Math.round(v));
        return parseFloat(v.toFixed(2)).toString();
      }

      /**
       * Convert dB value to radius in [0,1] using current minDb/maxDb and power transform
       * radius = ( (db - min) / (max - min) )^5  (clamped)
       */
      function dbToRadius(db) {
        const lo = Math.min(minDb, maxDb);
        const hi = Math.max(minDb, maxDb);
        if (isNaN(db) || !isFinite(db)) db = lo;

        let s = (db - lo) / (hi - lo || 1);
        s = Math.max(0, Math.min(1, s));

        if (isNonLinearMode) {
          return Math.pow(s, 5); // non-linear
        } else {
          return s; // linear
        }
      }

      /**
       * Catmull-Rom spline interpolation for closed curves
       * @param {Array} points - Array of [theta (rad), r] pairs
       * @param {number} M - Number of sample points
       * @returns {Object} - {thetaSamples, rSamples}
       */
      function catmullRomClosedSample(points, M) {
        if (points.length < 2) return { thetaSamples: [], rSamples: new Array(M).fill(0) };

        // Ensure points are sorted by theta
        points = points.slice().sort((a,b)=>a[0]-b[0]);

        // Make cyclic by adding extra points at end using +2π offset
        const p = points.map(pn => [pn[0], pn[1]]);
        p.push([points[0][0] + 2 * Math.PI, points[0][1]]);
        p.push([points[1 % points.length][0] + 2 * Math.PI, points[1 % points.length][1]]);

        // Generate sample theta array
        const thetaSamples = Array.from({ length: M }, (_, i) => i * 2 * Math.PI / (M - 1));
        const rOut = new Array(M);

        for (let si = 0; si < M; si++) {
          const t = thetaSamples[si];
          
          // Find segment k where p[k].theta <= t < p[k+1].theta
          let k = 0;
          while (k + 1 < p.length && p[k + 1][0] <= t) k++;

          // Get surrounding points for Catmull-Rom
          const i0 = Math.max(0, k - 1);
          const i1 = k;
          const i2 = Math.min(p.length - 1, k + 1);
          const i3 = Math.min(p.length - 1, k + 2);
          
          const t0 = p[i1][0], t1 = p[i2][0];
          const denom = (t1 - t0) || 1e-6;
          const u = (t - t0) / denom;

          const P0 = p[i0][1], P1 = p[i1][1], P2 = p[i2][1], P3 = p[i3][1];

          // Catmull-Rom interpolation
          const u2 = u * u, u3 = u2 * u;
          const a = -0.5 * P0 + 1.5 * P1 - 1.5 * P2 + 0.5 * P3;
          const b = P0 - 2.5 * P1 + 2 * P2 - 0.5 * P3;
          const c = -0.5 * P0 + 0.5 * P2;
          const d = P1;
          let val = a * u3 + b * u2 + c * u + d;

          // Clamp to reduce overshoot
          const localMin = Math.min(P0, P1, P2, P3);
          const localMax = Math.max(P0, P1, P2, P3);
          val = Math.max(localMin, Math.min(localMax, val));

          rOut[si] = val;
        }

        return { thetaSamples, rSamples: rOut };
      }

      // ========== UI Functions ==========

      /**
       * Create dB input fields based on step
       */
      function createDbRows(step, restorePrev = true) {
        prevTexts = dbInputs.map(inp => inp.value) || [];
        fieldsContainer.innerHTML = '';
        dbInputs = [];

        const nRows = Math.max(1, Math.floor(360 / step));
        for (let i = 0; i < nRows; i++) {
          const angle = i * step;
          const row = document.createElement('div');
          row.className = 'field-row';

          const lbl = document.createElement('div');
          lbl.className = 'deg';
          lbl.textContent = angle + '°';
          row.appendChild(lbl);

          const inp = document.createElement('input');
          inp.className = 'db-input';
          inp.type = 'text';
          inp.placeholder = 'dB';
          if (restorePrev && prevTexts[i]) inp.value = prevTexts[i];
          row.appendChild(inp);

          fieldsContainer.appendChild(row);
          dbInputs.push(inp);
        }
      }

      /**
       * Parse dB value from text input
       */
      function parseDbField(text) {
        if (!text) return null;
        const m = text.match(DB_REGEX);
        if (!m) return null;
        return parseFloat(m[0].replace(',', '.'));
      }

      /**
       * Validate and collect data from input fields (respecting current min/max)
       */
      function validateAndCollect() {
        errorEl.textContent = '';
        const stepVal = Number(stepInput.value);
        
        if (Number.isNaN(stepVal)) {
          return { err: 'Step value must be numeric.' };
        }
        if (!(1 <= stepVal && stepVal <= 180)) {
          return { err: 'Step is out of range (1-180).' };
        }

        const angles = [];
        const values = [];
        const errors = [];

        for (let idx = 0; idx < dbInputs.length; idx++) {
          const txt = dbInputs[idx].value.trim();
          if (txt === '') continue;
          
          const parsed = parseDbField(txt);
          if (parsed === null || Number.isNaN(parsed)) {
            errors.push(`Non-numeric value at field ${idx + 1}.`);
            continue;
          }
          if (parsed < Math.min(minDb, maxDb) || parsed > Math.max(minDb, maxDb)) {
            errors.push(`dB out of range at field ${idx + 1} (must be between ${formatDb(minDb)} and ${formatDb(maxDb)}).`);
            continue;
          }
          
          angles.push(idx * stepVal);
          values.push(parsed);
        }

        if (errors.length) return { err: errors.join(' ') };
        if (values.length < 2) return { err: 'Not enough data points...' };

        return { angles, values };
      }

      // ========== Storage Functions ==========

      try {
        const storedMode = localStorage.getItem('antennaDivisionMode');
        if (storedMode !== null) isNonLinearMode = storedMode === 'non-linear';
      } catch(e){}

      function saveFieldsToStorage() {
        try {
          const values = dbInputs.map(inp => inp.value);
          localStorage.setItem('antennaDbFields', JSON.stringify(values));
          localStorage.setItem('antennaStep', currentStep);
          localStorage.setItem('antennaMinDb', String(minDb));
          localStorage.setItem('antennaMaxDb', String(maxDb));
        } catch (e) {
          // ignore storage errors
        }
      }

      function restoreFieldsFromStorage() {
        try {
          const storedValues = JSON.parse(localStorage.getItem('antennaDbFields') || '[]');
          const storedStep = parseInt(localStorage.getItem('antennaStep')) || currentStep;
          const storedMin = parseFloat(localStorage.getItem('antennaMinDb'));
          const storedMax = parseFloat(localStorage.getItem('antennaMaxDb'));

          if (!Number.isNaN(storedMin)) minDb = storedMin;
          if (!Number.isNaN(storedMax)) maxDb = storedMax;

          // Ensure inputs reflect stored range
          minDbInput.value = minDb;
          maxDbInput.value = maxDb;

          stepInput.value = storedStep;
          currentStep = storedStep;
          createDbRows(currentStep, false);
          
          dbInputs.forEach((inp, idx) => {
            if (storedValues[idx] !== undefined) inp.value = storedValues[idx];
          });
        } catch (e) {
          // fallback to defaults
          minDbInput.value = minDb;
          maxDbInput.value = maxDb;
          createDbRows(currentStep, false);
        }
      }

      // ========== Plotting Helpers ==========

      /**
       * Build horizontal tick label traces - ONLY first 4 values (closest to max) are labeled
       */
      function buildHorizontalTickTraces() {
        // compute step and label values
        const step = (maxDb - minDb) / 10;
        const labelDbs = [];
        let labelCount = 5;
        if (!isNonLinearMode){
          labelCount = 10;
        }
        for (let i = 0; i < labelCount; i++) {
          labelDbs.push(maxDb - i * step);
        }
        return labelDbs.map(dbVal => ({
          type: "scatterpolar",
          mode: "text",
          theta: [0],
          r: [dbToRadius(dbVal)],
          text: [`${formatDb(dbVal)} dB`],
          textangle: 0,
          textposition: "middle left",
          showlegend: false,
          hoverinfo: "none"
        }));
      }

      /**
       * Build radial dotted lines (angular grid)
       */
      function buildRadialDottedLines(stepDeg = 10) {
        const lines = [];
        for (let deg = 0; deg < 360; deg += stepDeg) {
          lines.push({
            type: "scatterpolar",
            r: [0, 1],
            theta: [deg, deg],
            mode: "lines",
            line: {
              dash: 'dot',
              width: 1,
              color: 'rgba(0,0,0,0.2)'
            },
            hoverinfo: "none",
            showlegend: false
          });
        }
        return lines;
      }

      /**
       * Draw empty plot with grid only (uses current range)
       */
      function drawEmptyPlot() {
        const layout = {
          ...baseLayout(),
          polar: {
            ...baseLayout().polar,
            radialaxis: {
              ...baseLayout().polar.radialaxis,
              showticklabels: false,
              ticks: ""
            }
          },
          dragmode: false
        };

        const emptyTrace = {
          type: "scatterpolar",
          r: [0],
          theta: [0],
          mode: "lines",
          line: { width: 0 },
          hoverinfo: "none",
          showlegend: false
        };

        const tickTextTraces = buildHorizontalTickTraces();
        const radialDottedLines = buildRadialDottedLines(10);

        // build concentric circles (10 circles, unlabeled except first 4 handled by tickTextTraces)
        const step = (maxDb - minDb) / 10;
        const M = SMOOTH_POINTS;
        const thetaSamples = Array.from({ length: SMOOTH_POINTS }, (_, i) => i * 2 * Math.PI / SMOOTH_POINTS);
        const circleTraces = buildCircularLines(minDb, maxDb, thetaSamples);

        Plotly.react(
          plotDiv,
          [emptyTrace, 
            ...circleTraces, 
            ...radialDottedLines, 
            ...tickTextTraces],
          layout,
          { responsive: true, staticPlot: true }
        );
      }

      /**
       * Draw circular lines
       */
      function buildCircularLines(minDb, maxDb, thetaSamples) {
        const lines = [];
        const step = (maxDb - minDb) / NUM_CIRCLES;

        for (let i = 0; i < NUM_CIRCLES; i++) {
          const db = maxDb - i * step;
          const rr = thetaSamples.map(() => dbToRadius(db));
          const thdeg = thetaSamples.map(t => t * 180 / Math.PI);

          lines.push({
            type: "scatterpolar",
            r: rr,
            theta: thdeg,
            mode: "lines",
            line: { width: 0.7, color: "rgba(0,0,0,0.25)" },
            hoverinfo: "none",
            showlegend: false
          });
        }
        return lines;
      }

      function dbToRadiusScaled(db, minDb, maxDb) {
        // normalize (db - maxDb) because 0 dB is outer ring
        const t = (db - maxDb) / (minDb - maxDb);
        return Math.max(0, Math.min(1, t)); // clamp
      }

      /**
       * Core plotting function - draws data respecting minDb/maxDb and 10 concentric circles
       */
      function plotData(anglesDeg, valuesDb) {
        // Convert angles to radians in [0, 2π)
        const anglesRad = anglesDeg.map(a => ((a % 360) + 360) % 360 * Math.PI / 180);
        
        // Sort by angle ascending
        const idx = anglesRad.map((v, i) => [v, i]).sort((a, b) => a[0] - b[0]).map(x => x[1]);
        const xSorted = idx.map(i => anglesRad[i]);
        const ySorted = idx.map(i => dbToRadius(valuesDb[i]));

        // Create points array [theta, r]
        const points = xSorted.map((th, i) => [th, ySorted[i]]);

        // Sample smooth values
        const M = SMOOTH_POINTS;
        const { thetaSamples, rSamples } = catmullRomClosedSample(points, M);

        // Convert to degrees for Plotly
        const thetaDeg = thetaSamples.map(t => t * 180 / Math.PI);

        // Main trace: blue line, width 4
        const traceSmooth = {
          type: 'scatterpolar',
          r: rSamples,
          theta: thetaDeg,
          mode: 'lines',
          line: { color: 'rgb(50,128,255)', width: 4 },
          hoverinfo: 'none'
        };

        // Marker points: red, size 12
        const tracePoints = {
          type: 'scatterpolar',
          r: ySorted,
          theta: xSorted.map(t => t * 180 / Math.PI),
          mode: 'markers',
          marker: { color: 'red', size: 12 },
          hovertemplate: '%{theta}°: %{r:.3f}<extra></extra>'
        };

        // Angular radial dotted lines (every 10°)
        const radialTraces = [];
        for (let deg = 0; deg < 360; deg += 10) {
          radialTraces.push({
            type: 'scatterpolar',
            r: [0, 1],
            theta: [deg, deg],
            mode: 'lines',
            line: { dash: 'dot', width: 0.8, color: 'rgba(200,200,200,0.25)' },
            hoverinfo: 'none',
            showlegend: false
          });
        }

        // Concentric circles - exactly 10 circles as requested
        const step = (maxDb - minDb) / 10;
        const dbLevels = [];
        for (let i = 0; i < 10; i++) {
          dbLevels.push(maxDb - i * step);
        }
        const circleTraces = buildCircularLines(minDb, maxDb, thetaSamples);

        const tickTextTraces = buildHorizontalTickTraces();

        const data = [
          ...radialTraces,
          ...circleTraces,
          ...buildRadialDottedLines(),
          traceSmooth,
          tracePoints,
          ...tickTextTraces
        ];

        // Build layout with radialaxis ticks only for first 4 values (converted to radii)
        const layout = {
          ...baseLayout(),
          polar: {
            ...baseLayout().polar,
            radialaxis: {
              ...baseLayout().polar.radialaxis,
              angle: 90,
              showticklabels: false,
              ticks: ""
            }
          },
          dragmode: false
        };

        Plotly.react(plotDiv, data, layout, {
          responsive: true,
          staticPlot: true
        });
      }

      /**
       * Attempt to plot with validation
       */
      function attemptPlot(isInitial = false) {
        if (isInitial instanceof Event) isInitial = false;

        errorEl.textContent = '';
        const res = validateAndCollect();

        if (res.err) {
          drawEmptyPlot();
          if (!isInitial || (res.err && !res.err.includes('Not enough data points'))) {
            errorEl.textContent = res.err;
          }
          return;
        }

        try {
          plotData(res.angles, res.values);
        } catch (e) {
          errorEl.textContent = 'Error plotting data: ' + (e && e.message ? e.message : e);
        }
      }

      // ========== Layout / Base config ==========

      function baseLayout() {
        // radialaxis tickvals/text -> only first 4 (closest to max)
        const step = (maxDb - minDb) / 10;
        const labeled = [];
        for (let i = 0; i < 6; i++) labeled.push(maxDb - i * step);
        const tickvals = labeled.map(dbToRadius);
        const ticktext = labeled.map(d => formatDb(d));

        return {
          polar: {
            bgcolor: 'rgba(0,0,0,0)',
            radialaxis: {
              visible: true,
              range: [0, 1],
              angle: 90,
              showticklabels: true,
              tickmode: 'array',
              tickvals: tickvals,
              ticktext: ticktext,
              tickfont: { color: 'rgba(0,0,0,0.8)' },
              gridcolor: 'rgba(0,0,0,0.2)'
            },
            angularaxis: {
              rotation: 90,
              direction: "counterclockwise",
              tickmode: 'array',
              tickvals: [0, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300, 330],
              ticktext: ['0°', '30°', '60°', '90°', '120°', '150°', '180°', '210°', '240°', '270°', '300°', '330°'],
              tickfont: { color: 'rgba(0,0,0,0.9)' },
              gridcolor: 'rgba(0,0,0,0.2)'
            }
          },
          showlegend: false,
          margin: { t: 38, b: 38, l: 38, r: 38 },
          paper_bgcolor: 'rgba(255, 255, 255, 1)',
          plot_bgcolor: 'rgba(255, 255, 255, 1)'
        };
      }

      // ========== Event Handlers ==========

      function onSetStep() {
        const prevTextsLocal = dbInputs.map(inp => inp.value) || [];
        const val = Number(stepInput.value);
        
        if (Number.isNaN(val)) {
          errorEl.textContent = 'Step value must be numeric.';
          return;
        }
        if (!(1 <= val && val <= 180)) {
          errorEl.textContent = 'Step is out of range (1-180).';
          return;
        }
        
        currentStep = Math.floor(val);
        prevTexts = prevTextsLocal;
        createDbRows(currentStep, true);
        errorEl.textContent = '';
        saveFieldsToStorage();
      }

      function onMirror() {
        const n = dbInputs.length;
        if (n < 2) {
          errorEl.textContent = 'Not enough fields to mirror.';
          return;
        }
        
        const texts = dbInputs.map(inp => inp.value.trim());
        for (let i = 2; i <= n; i++) {
          const target = n - (i - 2);
          if (target <= i) break;
          texts[target - 1] = texts[i - 1];
        }
        
        for (let i = 0; i < n; i++) dbInputs[i].value = texts[i] || '';
        attemptPlot();
        saveFieldsToStorage();
      }

      function onSave() {
        const res = validateAndCollect();
        if (res.err) {
          errorEl.textContent = res.err;
          return;
        }
        
        Plotly.toImage(plotDiv, { format: 'png', height: 600, width: 600, scale: 2 })
          .then(function(dataUrl) {
            const a = document.createElement('a');
            a.href = dataUrl;
            a.download = 'antenna_plot.png';
            document.body.appendChild(a);
            a.click();
            a.remove();
          })
          .catch(function(err) {
            errorEl.textContent = 'Saving error: ' + (err && err.message ? err.message : err);
          });
      }

      function onClearFields() {
        dbInputs.forEach(inp => inp.value = '');
        localStorage.removeItem('antennaDbFields');
        drawEmptyPlot();
        hasDataPlotted = false; // no line plotted
      }

      function onSetRange() {
        errorEl.textContent = '';
        const minVal = parseFloat(minDbInput.value);
        const maxVal = parseFloat(maxDbInput.value);

        if (Number.isNaN(minVal) || Number.isNaN(maxVal)) {
          errorEl.textContent = 'Min/Max must be numeric.';
          return;
        }
        if (!(minVal < maxVal)) {
          errorEl.textContent = 'Min dB must be less than Max dB.';
          return;
        }

        if (minVal < -1000 || maxVal > 1000) {
          errorEl.textContent = 'Min/Max out of allowed range.';
          return;
        }

        minDb = minVal;
        maxDb = maxVal;

        // Adjust all current dB input values to fit within new range
        dbInputs.forEach(inp => {
          let val = parseDbField(inp.value);
          if (val !== null) {
            if (val < minDb) val = minDb;
            if (val > maxDb) val = maxDb;
            inp.value = formatDb(val);
          }
        });

        // Save updated values
        saveFieldsToStorage();

        // Redraw plot smartly
        if (hasDataPlotted) {
          attemptPlot(); // redraw with existing line
        } else {
          drawEmptyPlot(); // redraw empty
        }
      }

      // ========== Event Listeners ==========
      drawBtn.addEventListener('click', function() {
        attemptPlot();
        hasDataPlotted = true; // mark that line data exists
      });
      setStepBtn.addEventListener('click', onSetStep);
      mirrorBtn.addEventListener('click', onMirror);
      saveBtn.addEventListener('click', onSave);
      clearFieldsBtn.addEventListener('click', onClearFields);
      setRangeBtn.addEventListener('click', onSetRange);

      const toggleModeBtn = document.getElementById('toggleModeBtn');

      function updateToggleButton() {
        toggleModeBtn.textContent = isNonLinearMode ? 'Non-linear' : 'Linear';
      }

      toggleModeBtn.addEventListener('click', () => {
        isNonLinearMode = !isNonLinearMode;
        try { localStorage.setItem('antennaDivisionMode', isNonLinearMode ? 'non-linear' : 'linear'); } catch(e){}
        updateToggleButton();

        // redraw plot based on mode
        if (hasDataPlotted) attemptPlot();
        else drawEmptyPlot();
      });

      fieldsContainer.addEventListener('input', saveFieldsToStorage);
      stepInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') onSetStep();
      });
      minDbInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') onSetRange();
      });
      maxDbInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') onSetRange();
      });

      // Also save range changes immediately to storage (on input)
      minDbInput.addEventListener('input', function() {
        // optimistic set but don't redraw until Set range pressed
        // we still update localStorage to persist typed value
        try {
          localStorage.setItem('antennaMinDbDraft', minDbInput.value);
        } catch(e){}
      });
      maxDbInput.addEventListener('input', function() {
        try {
          localStorage.setItem('antennaMaxDbDraft', maxDbInput.value);
        } catch(e){}
      });

      // ========== Initialization ==========

      restoreFieldsFromStorage();
      // If there were draft values from typing, populate inputs but don't apply until Set range
      try {
        const dMin = localStorage.getItem('antennaMinDbDraft');
        const dMax = localStorage.getItem('antennaMaxDbDraft');
        if (dMin !== null) minDbInput.value = dMin;
        if (dMax !== null) maxDbInput.value = dMax;
      } catch(e){}

      drawEmptyPlot();
      updateToggleButton(); // set correct label

      // Expose for debugging
      window._antennaApp = {
        createDbRows,
        attemptPlot,
        plotData,
        catmullRomClosedSample,
        setRange: onSetRange,
        getRange: () => ({ minDb, maxDb })
      };
    })();
  </script>
</body>
</html>
